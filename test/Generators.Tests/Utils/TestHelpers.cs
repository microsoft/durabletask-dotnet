// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System.Reflection;
using System.Text;
using Microsoft.Azure.Functions.Worker;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.Extensions.DependencyInjection;

namespace Microsoft.DurableTask.Generators.Tests.Utils;

static class TestHelpers
{
    public static Task RunTestAsync<TSourceGenerator>(
        string expectedFileName,
        string inputSource,
        string? expectedOutputSource,
        bool isDurableFunctions) where TSourceGenerator : IIncrementalGenerator, new()
    {
        return RunTestAsync<TSourceGenerator>(
            expectedFileName,
            inputSource,
            expectedOutputSource,
            isDurableFunctions,
            projectType: null);
    }

    public static Task RunTestAsync<TSourceGenerator>(
        string expectedFileName,
        string inputSource,
        string expectedOutputSource,
        bool isDurableFunctions,
        string? projectType) where TSourceGenerator : IIncrementalGenerator, new()
    {
        CSharpSourceGeneratorVerifier<TSourceGenerator>.Test test = new()
        {
            TestState =
            {
                Sources = { inputSource },
                AdditionalReferences =
                {
                    // Durable Task SDK
                    typeof(TaskActivityContext).Assembly,
                },
            },
        };

        // Only add generated source if expectedOutputSource is not null
        if (expectedOutputSource != null)
        {
            test.TestState.GeneratedSources.Add(
                (typeof(TSourceGenerator), expectedFileName, SourceText.From(expectedOutputSource, Encoding.UTF8, SourceHashAlgorithm.Sha256)));
        }

        if (isDurableFunctions)
        {
            // Durable Functions code generation is triggered by the presence of the
            // Durable Functions worker extension for .NET Isolated.
            Assembly functionsWorkerAbstractions = typeof(FunctionAttribute).Assembly;
            test.TestState.AdditionalReferences.Add(functionsWorkerAbstractions);

            Assembly functionsWorkerCore = typeof(FunctionContext).Assembly;
            test.TestState.AdditionalReferences.Add(functionsWorkerCore);

            // OrchestrationTriggerAttribute and ActivityTriggerAttribute are in the DurableTask extension
            Assembly durableExtension = typeof(OrchestrationTriggerAttribute).Assembly;
            test.TestState.AdditionalReferences.Add(durableExtension);

            Assembly dependencyInjection = typeof(ActivatorUtilities).Assembly;
            test.TestState.AdditionalReferences.Add(dependencyInjection);
        }

        // Set the project type configuration if specified
        if (projectType != null)
        {
            test.TestState.AnalyzerConfigFiles.Add(
                ("/.globalconfig", $"""
                is_global = true
                build_property.DurableTaskGeneratorProjectType = {projectType}
                """));
        }

        return test.RunAsync();
    }

    public static string WrapAndFormat(string generatedClassName, string methodList, bool isDurableFunctions = false)
    {
        string formattedMethodList = IndentLines(spaces: 8, methodList);
        string usings = @"
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.DurableTask.Internal;";

        if (isDurableFunctions)
        {
            usings += @"
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.DependencyInjection;";
        }

        return $@"
// <auto-generated/>
#nullable enable
{usings}

namespace Microsoft.DurableTask
{{
    public static class {generatedClassName}
    {{
        {formattedMethodList.TrimStart()}
    }}
}}
".TrimStart();
    }

    static string IndentLines(int spaces, string multilineText)
    {
        string indent = new(' ', spaces);
        StringBuilder sb = new();

        foreach (string line in multilineText.Trim().Split(Environment.NewLine))
        {
            if (line.Length > 0)
            {
                sb.Append(indent);
            }

            sb.AppendLine(line);
        }

        return sb.ToString().TrimEnd();
    }

    internal static object DeIndent(string code, int spacesToRemove)
    {
        StringBuilder sb = new(code.Length);
        foreach (string line in code.Split(Environment.NewLine))
        {
            int charsToSkip = Math.Min(spacesToRemove, line.Length);
            sb.AppendLine(line[charsToSkip..]);
        }

        return sb.ToString();
    }

    internal static string GetDefaultInputType(string inputType)
    {
        static bool IsValueType(string typeExpression)
        {
            // This list is obviously incomplete, but should be enhanced as necessary for testing
            switch (typeExpression)
            {
                case "int":
                case "float":
                case "double":
                case "byte":
                case "Guid":
                case "TimeSpan":
                case "DateTime":
                case "DateTimeOffset":
                    return true;
                default:
                    Type? runtimeType = Type.GetType(typeExpression, throwOnError: false);
                    return runtimeType != null && runtimeType.IsValueType;
            }
        }

        if (inputType.StartsWith("(") || inputType.EndsWith('?') || IsValueType(inputType))
        {
            return inputType;
        }

        return inputType + "?";
    }
}
