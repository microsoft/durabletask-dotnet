// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using DurableTask.Core;

namespace DurableTask;

// TODO: This is public only because it's needed for Functions. Consider
//       a design that doesn't require this type to be public.
public class TaskOrchestrationShim<TInput, TOutput> : TaskOrchestrationShim
{
    public TaskOrchestrationShim(
        IWorkerContext workerContext,
        TaskName name,
        Func<TaskOrchestrationContext, TInput?, Task<TOutput?>> implementation)
        : base(workerContext, name, new FuncTaskOrchestrator<TInput, TOutput>(implementation))
    {
    }
}

// TODO: Move to its own file
/// <summary>
/// Implementation of <see cref="TaskOrchestratorBase{TInput, TOutput}"/> that uses
/// a <see cref="Func{T, TResult}"/> delegate as its implementation.
/// </summary>
/// <typeparam name="TInput">The orchestrator input type.</typeparam>
/// <typeparam name="TOutput">The orchestrator output type.</typeparam>
public class FuncTaskOrchestrator<TInput, TOutput> : TaskOrchestratorBase<TInput, TOutput>
{
    readonly Func<TaskOrchestrationContext, TInput?, Task<TOutput?>> implementation;

    /// <summary>
    /// Initializes a new instance of the <see cref="FuncTaskOrchestrator{TInput, TOutput}"/> class.
    /// </summary>
    /// <param name="implementation">The orchestrator function.</param>
    public FuncTaskOrchestrator(Func<TaskOrchestrationContext, TInput?, Task<TOutput?>> implementation)
    {
        this.implementation = implementation;
    }

    /// <inheritdoc/>
    protected override Task<TOutput?> OnRunAsync(TaskOrchestrationContext context, TInput? input)
    {
        return this.implementation(context, input);
    }
}

// TODO: This is public only because it's needed for Functions. Consider
//       a design that doesn't require this type to be public.
public class TaskOrchestrationShim : TaskOrchestration
{
    readonly TaskName name;
    readonly ITaskOrchestrator implementation;
    readonly IWorkerContext workerContext;

    TaskOrchestrationContextWrapper? wrapperContext;

    public TaskOrchestrationShim(
        IWorkerContext workerContext,
        TaskName name,
        ITaskOrchestrator implementation)
    {
        this.workerContext = workerContext;
        this.name = name;
        this.implementation = implementation;
    }

    public override async Task<string?> Execute(OrchestrationContext innerContext, string rawInput)
    {
        this.wrapperContext = new(innerContext, this.name, this.workerContext);

        object? input = this.workerContext.DataConverter.Deserialize(rawInput, this.implementation.InputType);

        // NOTE: If this throws, the error response will be generated by DurableTask.Core. However,
        //       it won't be consistent with our expected format. We currently work around this
        //       in the gRPC handling code, but ideally we wouldn't need this workaround.
        object? output = await this.implementation.RunAsync(this.wrapperContext, input);

        // Return the output (if any) as a serialized string.
        return this.workerContext.DataConverter.Serialize(output);
    }

    public override string? GetStatus()
    {
        return this.wrapperContext?.GetDeserializedCustomStatus();
    }

    public override void RaiseEvent(OrchestrationContext context, string name, string input)
    {
        this.wrapperContext?.CompleteExternalEvent(name, input);
    }

    sealed class TaskOrchestrationContextWrapper : TaskOrchestrationContext
    {
        readonly Dictionary<string, IEventSource> externalEventSources = new(StringComparer.OrdinalIgnoreCase);
        readonly NamedQueue<string> externalEventBuffer = new();
        readonly Queue<Action> localActivityCalls = new();

        readonly OrchestrationContext innerContext;
        readonly TaskName name;
        readonly IWorkerContext workerContext;

        object? customStatus;

        public TaskOrchestrationContextWrapper(
            OrchestrationContext innerContext,
            TaskName name,
            IWorkerContext workerContext)
        {
            this.innerContext = innerContext;
            this.name = name;
            this.workerContext = workerContext;
        }

        public override TaskName Name => this.name;

        public override string InstanceId => this.innerContext.OrchestrationInstance.InstanceId;

        public override bool IsReplaying => this.innerContext.IsReplaying;

        public override DateTime CurrentDateTimeUtc => this.innerContext.CurrentUtcDateTime;

        public override async Task<T> CallActivityAsync<T>(
            TaskName name,
            object? input = null,
            TaskOptions? options = null)
        {
            try
            {
                // TODO: Retry options
                return await this.innerContext.ScheduleTask<T>(name.Name, name.Version, input);
            }
            catch (DurableTask.Core.Exceptions.TaskFailedException coreTfe)
            {
                // Hide the core DTFx types and instead use our own
                throw new TaskFailedException(
                    taskName: name,
                    taskId: coreTfe.ScheduleId,
                    errorName: coreTfe.FailureDetails?.ErrorName ?? "(unknown)",
                    errorMessage: coreTfe.FailureDetails?.ErrorMessage ?? "(unknown)",
                    errorDetails: coreTfe.FailureDetails?.ErrorDetails);
            }
        }

        [Obsolete("This method is not yet fully implemented")]
        public override Task<T> CallActivityAsync<T>(Func<object?, T> activityLambda, object? input = null, TaskOptions? options = null)
        {
            if (options != null)
            {
                throw new NotImplementedException($"{nameof(TaskOptions)} are not yet supported.");
            }

            TaskCompletionSource<T> tcs = new();
            this.localActivityCalls.Enqueue(() =>
            {
                try
                {
                    T output = activityLambda(input);
                    tcs.SetResult(output);
                }
                catch (Exception ex)
                {
                    tcs.SetException(ex);
                }
            });

            return tcs.Task;
        }

        internal void ExecuteLocalActivityCalls()
        {
            while (this.localActivityCalls.Count > 0)
            {
                Action localActivityLambda = this.localActivityCalls.Dequeue();

                // Exceptions are never expected to escape here
                localActivityLambda.Invoke();
            }
        }

        public override Task<TResult> CallSubOrchestratorAsync<TResult>(
            TaskName orchestratorName,
            string? instanceId = null,
            object? input = null,
            TaskOptions? options = null)
        {
            if (options != null)
            {
                throw new NotImplementedException($"{nameof(TaskOptions)} are not yet supported.");
            }

            // TODO: Check to see if this orchestrator is defined

            // TODO: Support for retry options and custom deserialization via TaskOptions
            return this.innerContext.CreateSubOrchestrationInstance<TResult>(
                orchestratorName.Name,
                orchestratorName.Version,
                instanceId ?? Guid.NewGuid().ToString("N"),
                input);
        }

        public override Task CreateTimer(DateTime fireAt, CancellationToken cancellationToken)
        {
            return this.innerContext.CreateTimer<object>(fireAt, state: null!, cancellationToken);
        }

        public override Task<T> WaitForExternalEvent<T>(string eventName, CancellationToken cancellationToken = default)
        {
            // Return immediately if this external event has already arrived.
            if (this.externalEventBuffer.TryTake(eventName, out string? bufferedEventPayload))
            {
                return Task.FromResult(this.workerContext.DataConverter.Deserialize<T>(bufferedEventPayload));
            }

            // Create a task completion source that will be set when the external event arrives.
            EventTaskCompletionSource<T> eventSource = new();
            if (this.externalEventSources.TryGetValue(eventName, out IEventSource? existing))
            {
                if (existing.EventType != typeof(T))
                {
                    throw new ArgumentException($"Events with the same name must have the same type argument. Expected {existing.EventType.FullName}.");
                }

                existing.Next = eventSource;
            }
            else
            {
                this.externalEventSources.Add(eventName, eventSource);
            }

            cancellationToken.Register(() => eventSource.TrySetCanceled(cancellationToken));
            return eventSource.Task;
        }

        public void CompleteExternalEvent(string eventName, string rawEventPayload)
        {
            if (this.externalEventSources.TryGetValue(eventName, out IEventSource? waiter))
            {
                object? value = this.workerContext.DataConverter.Deserialize(rawEventPayload, waiter.EventType);

                // Events are completed in FIFO order. Remove the key if the last event was delivered.
                if (waiter.Next == null)
                {
                    this.externalEventSources.Remove(eventName);
                }
                else
                {
                    this.externalEventSources[eventName] = waiter.Next;
                }

                waiter.TrySetResult(value);
            }
            else
            {
                // The orchestrator isn't waiting for this event (yet?). Save it in case
                // the orchestrator wants it later.
                this.externalEventBuffer.Add(eventName, rawEventPayload);
            }
        }

        public override void SetCustomStatus(object? customStatus)
        {
            this.customStatus = customStatus;
        }

        /// <inheritdoc/>
        public override void ContinueAsNew(object newInput, bool preserveUnprocessedEvents = true)
        {
            this.innerContext.ContinueAsNew(newInput);

            if (preserveUnprocessedEvents)
            {
                // Send all the buffered external events to ourself.
                OrchestrationInstance instance = new() { InstanceId = this.InstanceId };
                foreach ((string eventName, string eventPayload) in this.externalEventBuffer.TakeAll())
                {
                    this.innerContext.SendEvent(instance, eventName, eventPayload);
                }
            }
        }

        internal string? GetDeserializedCustomStatus()
        {
            return this.workerContext.DataConverter.Serialize(this.customStatus);
        }

        class EventTaskCompletionSource<T> : TaskCompletionSource<T>, IEventSource
        {
            /// <inheritdoc/>
            public Type EventType => typeof(T);

            /// <inheritdoc/>
            public IEventSource? Next { get; set; }

            /// <inheritdoc/>
            void IEventSource.TrySetResult(object result) => this.TrySetResult((T)result);
        }

        interface IEventSource
        {
            /// <summary>
            /// The type of the event stored in the completion source.
            /// </summary>
            Type EventType { get; }

            /// <summary>
            /// The next task completion source in the stack.
            /// </summary>
            IEventSource? Next { get; set; }

            /// <summary>
            /// Tries to set the result on tcs.
            /// </summary>
            /// <param name="result">The result.</param>
            void TrySetResult(object result);
        }

        class NamedQueue<TValue>
        {
            readonly Dictionary<string, Queue<TValue>> buffers = new(StringComparer.OrdinalIgnoreCase);

            public void Add(string name, TValue value)
            {
                if (!this.buffers.TryGetValue(name, out Queue<TValue>? queue))
                {
                    queue = new Queue<TValue>();
                    this.buffers[name] = queue;
                }

                queue.Enqueue(value);
            }

            public bool TryTake(string name, [NotNullWhen(true)] out TValue? value)
            {
                if (this.buffers.TryGetValue(name, out Queue<TValue>? queue))
                {
                    value = queue.Dequeue()!;
                    if (queue.Count == 0)
                    {
                        this.buffers.Remove(name);
                    }

                    return true;
                }

                value = default;
                return false;
            }

            public IEnumerable<(string eventName, TValue eventPayload)> TakeAll()
            {
                foreach ((string eventName, Queue<TValue> eventPayloads) in this.buffers)
                {
                    foreach (TValue payload in eventPayloads)
                    {
                        yield return (eventName, payload);
                    }
                }

                this.buffers.Clear();
            }
        }
    }
}
